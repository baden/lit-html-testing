{"version":3,"sources":["webpack:///webpack/bootstrap 1d7ac3cc752b706cb001","webpack:///./node_modules/lit-html/lit-html.js","webpack:///./node_modules/lit-html/lib/lit-extended.js","webpack:///./node_modules/lit-html/lib/until.js"],"names":["__webpack_require__","moduleId","installedModules","exports","module","i","l","modules","call","parentJsonpFunction","window","chunkIds","moreModules","executeModules","chunkId","result","resolves","length","installedChunks","push","Object","prototype","hasOwnProperty","shift","s","2","e","onScriptComplete","script","onerror","onload","clearTimeout","timeout","chunk","Error","undefined","installedChunkData","Promise","resolve","promise","reject","head","document","getElementsByTagName","createElement","type","charset","async","nc","setAttribute","src","p","setTimeout","appendChild","m","c","d","name","getter","o","defineProperty","configurable","enumerable","get","n","__esModule","object","property","oe","err","console","error","litTag","strings","values","templates","isSvg","key","envCachesTemplates","join","template","Template","set","TemplateResult","__webpack_exports__","container","partCallback","defaultPartCallback","instance","__templateInstance","_partCallback","update","TemplateInstance","fragment","_clone","child","lastChild","removeChild","t","Map","svgTemplates","[object Object]","this","attributeMarker","Math","random","textRegex","hasTagsRegex","attrOrTextRegex","RegExp","TemplatePart","index","rawName","svg","parts","element","innerHTML","_getHtml","walker","createTreeWalker","content","partIndex","nodesToRemove","previousNode","currentNode","nextNode","node","nodeType","hasAttributes","attributes","attribute","item","attributeStrings","value","split","attributeString","substring","match","removeAttribute","nodeValue","parent","parentNode","lastIndex","textContent","insertBefore","createTextNode","previousSibling","nextSibling","trim","Text","a","isTextBinding","html","getValue","part","__litDirective","f","AttributePart","size","startIndex","text","v","Array","isArray","Symbol","iterator","NodePart","startNode","endNode","_previousValue","_setText","_setTemplateResult","_setIterable","Node","_setNode","then","_setPromise","clear","_insert","TEXT_NODE","itemParts","itemPart","itemStart","setValue","lastPart","templatePart","_parts","valueIndex","importNode","svgElement","firstChild","nodes","childNodes","__WEBPACK_IMPORTED_MODULE_0__lit_html_js__","extendedPartCallback","startsWith","eventName","EventPart","endsWith","PropertyPart","listener","_listener","removeEventListener","addEventListener","event","handleEvent","defaultContent"],"mappings":"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","file":"vendor.bundle.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [], result;\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n \t\tif(executeModules) {\n \t\t\tfor(i=0; i < executeModules.length; i++) {\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = executeModules[i]);\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// objects to store loaded and loading chunks\n \tvar installedChunks = {\n \t\t2: 0\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\tvar installedChunkData = installedChunks[chunkId];\n \t\tif(installedChunkData === 0) {\n \t\t\treturn new Promise(function(resolve) { resolve(); });\n \t\t}\n\n \t\t// a Promise means \"currently loading\".\n \t\tif(installedChunkData) {\n \t\t\treturn installedChunkData[2];\n \t\t}\n\n \t\t// setup Promise in chunk cache\n \t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n \t\t});\n \t\tinstalledChunkData[2] = promise;\n\n \t\t// start chunk loading\n \t\tvar head = document.getElementsByTagName('head')[0];\n \t\tvar script = document.createElement('script');\n \t\tscript.type = 'text/javascript';\n \t\tscript.charset = 'utf-8';\n \t\tscript.async = true;\n \t\tscript.timeout = 120000;\n\n \t\tif (__webpack_require__.nc) {\n \t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n \t\t}\n \t\tscript.src = __webpack_require__.p + \"./\" + chunkId + \".js\";\n \t\tvar timeout = setTimeout(onScriptComplete, 120000);\n \t\tscript.onerror = script.onload = onScriptComplete;\n \t\tfunction onScriptComplete() {\n \t\t\t// avoid mem leaks in IE.\n \t\t\tscript.onerror = script.onload = null;\n \t\t\tclearTimeout(timeout);\n \t\t\tvar chunk = installedChunks[chunkId];\n \t\t\tif(chunk !== 0) {\n \t\t\t\tif(chunk) {\n \t\t\t\t\tchunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));\n \t\t\t\t}\n \t\t\t\tinstalledChunks[chunkId] = undefined;\n \t\t\t}\n \t\t};\n \t\thead.appendChild(script);\n\n \t\treturn promise;\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// on error function for async loading\n \t__webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1d7ac3cc752b706cb001","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * TypeScript has a problem with precompiling templates literals\n * https://github.com/Microsoft/TypeScript/issues/17956\n *\n * TODO(justinfagnani): Run tests compiled to ES5 with both Babel and\n * TypeScript to verify correctness.\n */\nconst envCachesTemplates = ((t) => t() === t())(() => ((s) => s) ``);\n// The first argument to JS template tags retain identity across multiple\n// calls to a tag for the same literal, so we can cache work done per literal\n// in a Map.\nconst templates = new Map();\nconst svgTemplates = new Map();\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = (strings, ...values) => litTag(strings, values, templates, false);\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = (strings, ...values) => litTag(strings, values, svgTemplates, true);\nfunction litTag(strings, values, templates, isSvg) {\n    const key = envCachesTemplates ?\n        strings :\n        strings.join('{{--uniqueness-workaround--}}');\n    let template = templates.get(key);\n    if (template === undefined) {\n        template = new Template(strings, isSvg);\n        templates.set(key, template);\n    }\n    return new TemplateResult(template, values);\n}\n/**\n * The return type of `html`, which holds a Template and the values from\n * interpolated expressions.\n */\nexport class TemplateResult {\n    constructor(template, values) {\n        this.template = template;\n        this.values = values;\n    }\n}\n/**\n * Renders a template to a container.\n *\n * To update a container with new values, reevaluate the template literal and\n * call `render` with the new result.\n */\nexport function render(result, container, partCallback = defaultPartCallback) {\n    let instance = container.__templateInstance;\n    // Repeat render, just call update()\n    if (instance !== undefined && instance.template === result.template &&\n        instance._partCallback === partCallback) {\n        instance.update(result.values);\n        return;\n    }\n    // First render, create a new TemplateInstance and append it\n    instance = new TemplateInstance(result.template, partCallback);\n    container.__templateInstance = instance;\n    const fragment = instance._clone();\n    instance.update(result.values);\n    let child;\n    while ((child = container.lastChild)) {\n        container.removeChild(child);\n    }\n    container.appendChild(fragment);\n}\n/**\n * An expression marker with embedded unique key to avoid\n * https://github.com/PolymerLabs/lit-html/issues/62\n */\nconst attributeMarker = `{{lit-${Math.random()}}}`;\n/**\n * Regex to scan the string preceding an expression to see if we're in a text\n * context, and not an attribute context.\n *\n * This works by seeing if we have a `>` not followed by a `<`. If there is a\n * `<` closer to the end of the strings, then we're inside a tag.\n */\nconst textRegex = />[^<]*$/;\nconst hasTagsRegex = /[^<]*/;\nconst textMarkerContent = '_-lit-html-_';\nconst textMarker = `<!--${textMarkerContent}-->`;\nconst attrOrTextRegex = new RegExp(`${attributeMarker}|${textMarker}`);\n/**\n * A placeholder for a dynamic expression in an HTML template.\n *\n * There are two built-in part types: AttributePart and NodePart. NodeParts\n * always represent a single dynamic expression, while AttributeParts may\n * represent as many expressions are contained in the attribute.\n *\n * A Template's parts are mutable, so parts can be replaced or modified\n * (possibly to implement different template semantics). The contract is that\n * parts can only be replaced, not removed, added or reordered, and parts must\n * always consume the correct number of values in their `update()` method.\n *\n * TODO(justinfagnani): That requirement is a little fragile. A\n * TemplateInstance could instead be more careful about which values it gives\n * to Part.update().\n */\nexport class TemplatePart {\n    constructor(type, index, name, rawName, strings) {\n        this.type = type;\n        this.index = index;\n        this.name = name;\n        this.rawName = rawName;\n        this.strings = strings;\n    }\n}\nexport class Template {\n    constructor(strings, svg = false) {\n        this.parts = [];\n        this.svg = svg;\n        this.element = document.createElement('template');\n        this.element.innerHTML = this._getHtml(strings, svg);\n        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n        const walker = document.createTreeWalker(this.element.content, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |\n               NodeFilter.SHOW_TEXT */, null, false);\n        let index = -1;\n        let partIndex = 0;\n        const nodesToRemove = [];\n        // The actual previous node, accounting for removals: if a node is removed\n        // it will never be the previousNode.\n        let previousNode;\n        // Used to set previousNode at the top of the loop.\n        let currentNode;\n        while (walker.nextNode()) {\n            index++;\n            previousNode = currentNode;\n            const node = currentNode = walker.currentNode;\n            if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n                if (!node.hasAttributes()) {\n                    continue;\n                }\n                const attributes = node.attributes;\n                for (let i = 0; i < attributes.length; i++) {\n                    const attribute = attributes.item(i);\n                    const attributeStrings = attribute.value.split(attrOrTextRegex);\n                    if (attributeStrings.length > 1) {\n                        // Get the template literal section leading up to the first\n                        // expression in this attribute attribute\n                        const attributeString = strings[partIndex];\n                        // Trim the trailing literal value if this is an interpolation\n                        const rawNameString = attributeString.substring(0, attributeString.length - attributeStrings[0].length);\n                        // Find the attribute name\n                        const rawName = rawNameString.match(/((?:\\w|[.\\-_$])+)=[\"']?$/)[1];\n                        this.parts.push(new TemplatePart('attribute', index, attribute.name, rawName, attributeStrings));\n                        node.removeAttribute(attribute.name);\n                        partIndex += attributeStrings.length - 1;\n                        i--;\n                    }\n                }\n            }\n            else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\n                const nodeValue = node.nodeValue;\n                const strings = nodeValue.split(attributeMarker);\n                if (strings.length > 1) {\n                    const parent = node.parentNode;\n                    const lastIndex = strings.length - 1;\n                    // We have a part for each match found\n                    partIndex += lastIndex;\n                    // We keep this current node, but reset its content to the last\n                    // literal part. We insert new literal nodes before this so that the\n                    // tree walker keeps its position correctly.\n                    node.textContent = strings[lastIndex];\n                    // Generate a new text node for each literal section\n                    // These nodes are also used as the markers for node parts\n                    for (let i = 0; i < lastIndex; i++) {\n                        parent.insertBefore(document.createTextNode(strings[i]), node);\n                        this.parts.push(new TemplatePart('node', index++));\n                    }\n                }\n                else {\n                    // Strip whitespace-only nodes, only between elements, or at the\n                    // beginning or end of elements.\n                    const previousSibling = node.previousSibling;\n                    const nextSibling = node.nextSibling;\n                    if ((previousSibling === null ||\n                        previousSibling.nodeType === 1 /* Node.ELEMENT_NODE */) &&\n                        (nextSibling === null ||\n                            nextSibling.nodeType === 1 /* Node.ELEMENT_NODE */) &&\n                        nodeValue.trim() === '') {\n                        nodesToRemove.push(node);\n                        currentNode = previousNode;\n                        index--;\n                    }\n                }\n            }\n            else if (node.nodeType === 8 /* Node.COMMENT_NODE */ &&\n                node.nodeValue === textMarkerContent) {\n                const parent = node.parentNode;\n                // If we don't have a previous node add a marker node.\n                // If the previousSibling is removed, because it's another part\n                // placholder, or empty text, add a marker node.\n                if (node.previousSibling === null ||\n                    node.previousSibling !== previousNode) {\n                    parent.insertBefore(new Text(), node);\n                }\n                else {\n                    index--;\n                }\n                this.parts.push(new TemplatePart('node', index++));\n                nodesToRemove.push(node);\n                // If we don't have a next node add a marker node.\n                // We don't have to check if the next node is going to be removed,\n                // because that node will induce a marker if so.\n                if (node.nextSibling === null) {\n                    parent.insertBefore(new Text(), node);\n                }\n                else {\n                    index--;\n                }\n                currentNode = previousNode;\n                partIndex++;\n            }\n        }\n        // Remove text binding nodes after the walk to not disturb the TreeWalker\n        for (const n of nodesToRemove) {\n            n.parentNode.removeChild(n);\n        }\n    }\n    /**\n     * Returns a string of HTML used to create a <template> element.\n     */\n    _getHtml(strings, svg) {\n        const l = strings.length;\n        const a = [];\n        let isTextBinding = false;\n        for (let i = 0; i < l - 1; i++) {\n            const s = strings[i];\n            a.push(s);\n            // We're in a text position if the previous string matches the\n            // textRegex. If it doesn't and the previous string has no tags, then\n            // we use the previous text position state.\n            isTextBinding = s.match(textRegex) !== null ||\n                (s.match(hasTagsRegex) !== null && isTextBinding);\n            a.push(isTextBinding ? textMarker : attributeMarker);\n        }\n        a.push(strings[l - 1]);\n        const html = a.join('');\n        return svg ? `<svg>${html}</svg>` : html;\n    }\n}\nexport const getValue = (part, value) => {\n    // `null` as the value of a Text node will render the string 'null'\n    // so we convert it to undefined\n    if (value != null && value.__litDirective === true) {\n        value = value(part);\n    }\n    return value === null ? undefined : value;\n};\nexport const directive = (f) => {\n    f.__litDirective = true;\n    return f;\n};\nexport class AttributePart {\n    constructor(instance, element, name, strings) {\n        this.instance = instance;\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n        this.size = strings.length - 1;\n    }\n    setValue(values, startIndex) {\n        const strings = this.strings;\n        let text = '';\n        for (let i = 0; i < strings.length; i++) {\n            text += strings[i];\n            if (i < strings.length - 1) {\n                const v = getValue(this, values[startIndex + i]);\n                if (v &&\n                    (Array.isArray(v) || typeof v !== 'string' && v[Symbol.iterator])) {\n                    for (const t of v) {\n                        // TODO: we need to recursively call getValue into iterables...\n                        text += t;\n                    }\n                }\n                else {\n                    text += v;\n                }\n            }\n        }\n        this.element.setAttribute(this.name, text);\n    }\n}\nexport class NodePart {\n    constructor(instance, startNode, endNode) {\n        this.instance = instance;\n        this.startNode = startNode;\n        this.endNode = endNode;\n        this._previousValue = undefined;\n    }\n    setValue(value) {\n        value = getValue(this, value);\n        if (value === null ||\n            !(typeof value === 'object' || typeof value === 'function')) {\n            // Handle primitive values\n            // If the value didn't change, do nothing\n            if (value === this._previousValue) {\n                return;\n            }\n            this._setText(value);\n        }\n        else if (value instanceof TemplateResult) {\n            this._setTemplateResult(value);\n        }\n        else if (Array.isArray(value) || value[Symbol.iterator]) {\n            this._setIterable(value);\n        }\n        else if (value instanceof Node) {\n            this._setNode(value);\n        }\n        else if (value.then !== undefined) {\n            this._setPromise(value);\n        }\n        else {\n            // Fallback, will render the string representation\n            this._setText(value);\n        }\n    }\n    _insert(node) {\n        this.endNode.parentNode.insertBefore(node, this.endNode);\n    }\n    _setNode(value) {\n        this.clear();\n        this._insert(value);\n        this._previousValue = value;\n    }\n    _setText(value) {\n        const node = this.startNode.nextSibling;\n        if (node === this.endNode.previousSibling &&\n            node.nodeType === Node.TEXT_NODE) {\n            // If we only have a single text node between the markers, we can just\n            // set its value, rather than replacing it.\n            // TODO(justinfagnani): Can we just check if _previousValue is\n            // primitive?\n            node.textContent = value;\n        }\n        else {\n            this._setNode(document.createTextNode(value === undefined ? '' : value));\n        }\n        this._previousValue = value;\n    }\n    _setTemplateResult(value) {\n        let instance;\n        if (this._previousValue &&\n            this._previousValue.template === value.template) {\n            instance = this._previousValue;\n        }\n        else {\n            instance =\n                new TemplateInstance(value.template, this.instance._partCallback);\n            this._setNode(instance._clone());\n            this._previousValue = instance;\n        }\n        instance.update(value.values);\n    }\n    _setIterable(value) {\n        // For an Iterable, we create a new InstancePart per item, then set its\n        // value to the item. This is a little bit of overhead for every item in\n        // an Iterable, but it lets us recurse easily and efficiently update Arrays\n        // of TemplateResults that will be commonly returned from expressions like:\n        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n        // If _previousValue is an array, then the previous render was of an\n        // iterable and _previousValue will contain the NodeParts from the previous\n        // render. If _previousValue is not an array, clear this part and make a new\n        // array for NodeParts.\n        if (!Array.isArray(this._previousValue)) {\n            this.clear();\n            this._previousValue = [];\n        }\n        // Lets us keep track of how many items we stamped so we can clear leftover\n        // items from a previous render\n        const itemParts = this._previousValue;\n        let partIndex = 0;\n        for (const item of value) {\n            // Try to reuse an existing part\n            let itemPart = itemParts[partIndex];\n            // If no existing part, create a new one\n            if (itemPart === undefined) {\n                // If we're creating the first item part, it's startNode should be the\n                // container's startNode\n                let itemStart = this.startNode;\n                // If we're not creating the first part, create a new separator marker\n                // node, and fix up the previous part's endNode to point to it\n                if (partIndex > 0) {\n                    const previousPart = itemParts[partIndex - 1];\n                    itemStart = previousPart.endNode = document.createTextNode('');\n                    this._insert(itemStart);\n                }\n                itemPart = new NodePart(this.instance, itemStart, this.endNode);\n                itemParts.push(itemPart);\n            }\n            itemPart.setValue(item);\n            partIndex++;\n        }\n        if (partIndex === 0) {\n            this.clear();\n            this._previousValue = undefined;\n        }\n        else if (partIndex < itemParts.length) {\n            const lastPart = itemParts[partIndex - 1];\n            // Truncate the parts array so _previousValue reflects the current state\n            itemParts.length = partIndex;\n            this.clear(lastPart.endNode.previousSibling);\n            lastPart.endNode = this.endNode;\n        }\n    }\n    _setPromise(value) {\n        value.then((v) => {\n            if (this._previousValue === value) {\n                this.setValue(v);\n            }\n        });\n        this._previousValue = value;\n    }\n    clear(startNode = this.startNode) {\n        let node;\n        while ((node = startNode.nextSibling) !== this.endNode) {\n            node.parentNode.removeChild(node);\n        }\n    }\n}\nexport const defaultPartCallback = (instance, templatePart, node) => {\n    if (templatePart.type === 'attribute') {\n        return new AttributePart(instance, node, templatePart.name, templatePart.strings);\n    }\n    else if (templatePart.type === 'node') {\n        return new NodePart(instance, node, node.nextSibling);\n    }\n    throw new Error(`Unknown part type ${templatePart.type}`);\n};\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\nexport class TemplateInstance {\n    constructor(template, partCallback = defaultPartCallback) {\n        this._parts = [];\n        this.template = template;\n        this._partCallback = partCallback;\n    }\n    update(values) {\n        let valueIndex = 0;\n        for (const part of this._parts) {\n            if (part.size === undefined) {\n                part.setValue(values[valueIndex]);\n                valueIndex++;\n            }\n            else {\n                part.setValue(values, valueIndex);\n                valueIndex += part.size;\n            }\n        }\n    }\n    _clone() {\n        const fragment = document.importNode(this.template.element.content, true);\n        if (this.template.parts.length > 0) {\n            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be\n            // null\n            const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT */, null, false);\n            const parts = this.template.parts;\n            let index = 0;\n            let partIndex = 0;\n            let templatePart = parts[0];\n            let node = walker.nextNode();\n            while (node != null && partIndex < parts.length) {\n                if (index === templatePart.index) {\n                    this._parts.push(this._partCallback(this, templatePart, node));\n                    templatePart = parts[++partIndex];\n                }\n                else {\n                    index++;\n                    node = walker.nextNode();\n                }\n            }\n        }\n        if (this.template.svg) {\n            const svgElement = fragment.firstChild;\n            fragment.removeChild(svgElement);\n            const nodes = svgElement.childNodes;\n            for (let i = 0; i < nodes.length; i++) {\n                fragment.appendChild(nodes.item(i));\n            }\n        }\n        return fragment;\n    }\n}\n//# sourceMappingURL=lit-html.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lit-html/lit-html.js\n// module id = 0\n// module chunks = 2","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { AttributePart, defaultPartCallback, getValue, render as baseRender } from '../lit-html.js';\nexport { html } from '../lit-html.js';\n/**\n *\n * @param result Renders a `TemplateResult` to a container using the\n * `extendedPartCallback` PartCallback, which allows templates to set\n * properties and declarative event handlers.\n *\n * Properties are set by default, instead of attributes. Attribute names in\n * lit-html templates preserve case, so properties are case sensitive. If an\n * expression takes up an entire attribute value, then the property is set to\n * that value. If an expression is interpolated with a string or other\n * expressions then the property is set to the string result of the\n * interpolation.\n *\n * To set an attribute instead of a property, append a `$` suffix to the\n * attribute name.\n *\n * Example:\n *\n *     html`<button class$=\"primary\">Buy Now</button>`\n *\n * To set an event handler, prefix the attribute name with `on-`:\n *\n * Example:\n *\n *     html`<button on-click=${(e)=> this.onClickHandler(e)}>Buy Now</button>`\n *\n */\nexport function render(result, container) {\n    baseRender(result, container, extendedPartCallback);\n}\nexport const extendedPartCallback = (instance, templatePart, node) => {\n    if (templatePart.type === 'attribute') {\n        if (templatePart.rawName.startsWith('on-')) {\n            const eventName = templatePart.rawName.substring(3);\n            return new EventPart(instance, node, eventName);\n        }\n        if (templatePart.name.endsWith('$')) {\n            const name = templatePart.name.substring(0, templatePart.name.length - 1);\n            return new AttributePart(instance, node, name, templatePart.strings);\n        }\n        return new PropertyPart(instance, node, templatePart.rawName, templatePart.strings);\n    }\n    return defaultPartCallback(instance, templatePart, node);\n};\nexport class PropertyPart extends AttributePart {\n    setValue(values, startIndex) {\n        const s = this.strings;\n        let value;\n        if (s.length === 2 && s[0] === '' && s[s.length - 1] === '') {\n            // An expression that occupies the whole attribute value will leave\n            // leading and trailing empty strings.\n            value = getValue(this, values[startIndex]);\n        }\n        else {\n            // Interpolation, so interpolate\n            value = '';\n            for (let i = 0; i < s.length; i++) {\n                value += s[i];\n                if (i < s.length - 1) {\n                    value += getValue(this, values[startIndex + i]);\n                }\n            }\n        }\n        this.element[this.name] = value;\n    }\n}\nexport class EventPart {\n    constructor(instance, element, eventName) {\n        this.instance = instance;\n        this.element = element;\n        this.eventName = eventName;\n    }\n    setValue(value) {\n        const listener = getValue(this, value);\n        if (listener === this._listener) {\n            return;\n        }\n        if (listener == null) {\n            this.element.removeEventListener(this.eventName, this);\n        }\n        else if (this._listener == null) {\n            this.element.addEventListener(this.eventName, this);\n        }\n        this._listener = listener;\n    }\n    handleEvent(event) {\n        if (typeof this._listener === 'function') {\n            this._listener.call(this.element, event);\n        }\n        else if (typeof this._listener.handleEvent === 'function') {\n            this._listener.handleEvent(event);\n        }\n    }\n}\n//# sourceMappingURL=lit-extended.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lit-html/lib/lit-extended.js\n// module id = 1\n// module chunks = 2","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { directive } from '../lit-html.js';\n/**\n * Display `defaultContent` until `promise` resolves.\n */\nexport const until = (promise, defaultContent) => directive((part) => {\n    part.setValue(defaultContent);\n    return promise;\n});\n//# sourceMappingURL=until.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lit-html/lib/until.js\n// module id = 2\n// module chunks = 2"],"sourceRoot":""}