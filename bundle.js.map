{"version":3,"sources":["webpack:///webpack/bootstrap 7217fc93dc7cba4b9523","webpack:///./node_modules/lit-html/lit-html.js","webpack:///./src/index.js","webpack:///./src/app.js","webpack:///./node_modules/lit-html/lib/lit-extended.js"],"names":["__webpack_require__","moduleId","installedModules","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","result","container","partCallback","defaultPartCallback","instance","__templateInstance","undefined","template","_partCallback","update","values","TemplateInstance","fragment","_clone","child","lastChild","removeChild","appendChild","envCachesTemplates","t","templates","Map","strings","isSvg","key","join","Template","set","TemplateResult","litTag","[object Object]","this","attributeMarker","Math","random","textRegex","hasTagsRegex","attrOrTextRegex","RegExp","TemplatePart","type","index","rawName","svg","parts","element","document","createElement","innerHTML","_getHtml","walker","createTreeWalker","content","partIndex","nodesToRemove","previousNode","currentNode","nextNode","node","nodeType","hasAttributes","attributes","length","attribute","item","attributeStrings","value","split","attributeString","substring","match","push","removeAttribute","nodeValue","parent","parentNode","lastIndex","textContent","insertBefore","createTextNode","previousSibling","nextSibling","trim","Text","a","isTextBinding","html","getValue","part","__litDirective","AttributePart","size","startIndex","text","v","Array","isArray","Symbol","iterator","setAttribute","NodePart","startNode","endNode","_previousValue","_setText","_setTemplateResult","_setIterable","Node","_setNode","then","_setPromise","clear","_insert","TEXT_NODE","itemParts","itemPart","itemStart","setValue","lastPart","templatePart","Error","_parts","valueIndex","importNode","svgElement","firstChild","nodes","childNodes","__WEBPACK_IMPORTED_MODULE_0__app_js__","body","header","__WEBPACK_IMPORTED_MODULE_0_lit_html_lib_lit_extended__","App","counter","_counter","invalidate","e","console","log","_dec","_inc","needsRender","Promise","resolve","render","__WEBPACK_IMPORTED_MODULE_0__lit_html_js__","extendedPartCallback","startsWith","eventName","EventPart","endsWith","PropertyPart","listener","_listener","removeEventListener","addEventListener","event","handleEvent"],"mappings":"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","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 7217fc93dc7cba4b9523","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * TypeScript has a problem with precompiling templates literals\n * https://github.com/Microsoft/TypeScript/issues/17956\n *\n * TODO(justinfagnani): Run tests compiled to ES5 with both Babel and\n * TypeScript to verify correctness.\n */\nconst envCachesTemplates = ((t) => t() === t())(() => ((s) => s) ``);\n// The first argument to JS template tags retain identity across multiple\n// calls to a tag for the same literal, so we can cache work done per literal\n// in a Map.\nconst templates = new Map();\nconst svgTemplates = new Map();\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = (strings, ...values) => litTag(strings, values, templates, false);\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = (strings, ...values) => litTag(strings, values, svgTemplates, true);\nfunction litTag(strings, values, templates, isSvg) {\n    const key = envCachesTemplates ?\n        strings :\n        strings.join('{{--uniqueness-workaround--}}');\n    let template = templates.get(key);\n    if (template === undefined) {\n        template = new Template(strings, isSvg);\n        templates.set(key, template);\n    }\n    return new TemplateResult(template, values);\n}\n/**\n * The return type of `html`, which holds a Template and the values from\n * interpolated expressions.\n */\nexport class TemplateResult {\n    constructor(template, values) {\n        this.template = template;\n        this.values = values;\n    }\n}\n/**\n * Renders a template to a container.\n *\n * To update a container with new values, reevaluate the template literal and\n * call `render` with the new result.\n */\nexport function render(result, container, partCallback = defaultPartCallback) {\n    let instance = container.__templateInstance;\n    // Repeat render, just call update()\n    if (instance !== undefined && instance.template === result.template &&\n        instance._partCallback === partCallback) {\n        instance.update(result.values);\n        return;\n    }\n    // First render, create a new TemplateInstance and append it\n    instance = new TemplateInstance(result.template, partCallback);\n    container.__templateInstance = instance;\n    const fragment = instance._clone();\n    instance.update(result.values);\n    let child;\n    while ((child = container.lastChild)) {\n        container.removeChild(child);\n    }\n    container.appendChild(fragment);\n}\n/**\n * An expression marker with embedded unique key to avoid\n * https://github.com/PolymerLabs/lit-html/issues/62\n */\nconst attributeMarker = `{{lit-${Math.random()}}}`;\n/**\n * Regex to scan the string preceding an expression to see if we're in a text\n * context, and not an attribute context.\n *\n * This works by seeing if we have a `>` not followed by a `<`. If there is a\n * `<` closer to the end of the strings, then we're inside a tag.\n */\nconst textRegex = />[^<]*$/;\nconst hasTagsRegex = /[^<]*/;\nconst textMarkerContent = '_-lit-html-_';\nconst textMarker = `<!--${textMarkerContent}-->`;\nconst attrOrTextRegex = new RegExp(`${attributeMarker}|${textMarker}`);\n/**\n * A placeholder for a dynamic expression in an HTML template.\n *\n * There are two built-in part types: AttributePart and NodePart. NodeParts\n * always represent a single dynamic expression, while AttributeParts may\n * represent as many expressions are contained in the attribute.\n *\n * A Template's parts are mutable, so parts can be replaced or modified\n * (possibly to implement different template semantics). The contract is that\n * parts can only be replaced, not removed, added or reordered, and parts must\n * always consume the correct number of values in their `update()` method.\n *\n * TODO(justinfagnani): That requirement is a little fragile. A\n * TemplateInstance could instead be more careful about which values it gives\n * to Part.update().\n */\nexport class TemplatePart {\n    constructor(type, index, name, rawName, strings) {\n        this.type = type;\n        this.index = index;\n        this.name = name;\n        this.rawName = rawName;\n        this.strings = strings;\n    }\n}\nexport class Template {\n    constructor(strings, svg = false) {\n        this.parts = [];\n        this.svg = svg;\n        this.element = document.createElement('template');\n        this.element.innerHTML = this._getHtml(strings, svg);\n        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n        const walker = document.createTreeWalker(this.element.content, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |\n               NodeFilter.SHOW_TEXT */, null, false);\n        let index = -1;\n        let partIndex = 0;\n        const nodesToRemove = [];\n        // The actual previous node, accounting for removals: if a node is removed\n        // it will never be the previousNode.\n        let previousNode;\n        // Used to set previousNode at the top of the loop.\n        let currentNode;\n        while (walker.nextNode()) {\n            index++;\n            previousNode = currentNode;\n            const node = currentNode = walker.currentNode;\n            if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n                if (!node.hasAttributes()) {\n                    continue;\n                }\n                const attributes = node.attributes;\n                for (let i = 0; i < attributes.length; i++) {\n                    const attribute = attributes.item(i);\n                    const attributeStrings = attribute.value.split(attrOrTextRegex);\n                    if (attributeStrings.length > 1) {\n                        // Get the template literal section leading up to the first\n                        // expression in this attribute attribute\n                        const attributeString = strings[partIndex];\n                        // Trim the trailing literal value if this is an interpolation\n                        const rawNameString = attributeString.substring(0, attributeString.length - attributeStrings[0].length);\n                        // Find the attribute name\n                        const rawName = rawNameString.match(/((?:\\w|[.\\-_$])+)=[\"']?$/)[1];\n                        this.parts.push(new TemplatePart('attribute', index, attribute.name, rawName, attributeStrings));\n                        node.removeAttribute(attribute.name);\n                        partIndex += attributeStrings.length - 1;\n                        i--;\n                    }\n                }\n            }\n            else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\n                const nodeValue = node.nodeValue;\n                const strings = nodeValue.split(attributeMarker);\n                if (strings.length > 1) {\n                    const parent = node.parentNode;\n                    const lastIndex = strings.length - 1;\n                    // We have a part for each match found\n                    partIndex += lastIndex;\n                    // We keep this current node, but reset its content to the last\n                    // literal part. We insert new literal nodes before this so that the\n                    // tree walker keeps its position correctly.\n                    node.textContent = strings[lastIndex];\n                    // Generate a new text node for each literal section\n                    // These nodes are also used as the markers for node parts\n                    for (let i = 0; i < lastIndex; i++) {\n                        parent.insertBefore(document.createTextNode(strings[i]), node);\n                        this.parts.push(new TemplatePart('node', index++));\n                    }\n                }\n                else {\n                    // Strip whitespace-only nodes, only between elements, or at the\n                    // beginning or end of elements.\n                    const previousSibling = node.previousSibling;\n                    const nextSibling = node.nextSibling;\n                    if ((previousSibling === null ||\n                        previousSibling.nodeType === 1 /* Node.ELEMENT_NODE */) &&\n                        (nextSibling === null ||\n                            nextSibling.nodeType === 1 /* Node.ELEMENT_NODE */) &&\n                        nodeValue.trim() === '') {\n                        nodesToRemove.push(node);\n                        currentNode = previousNode;\n                        index--;\n                    }\n                }\n            }\n            else if (node.nodeType === 8 /* Node.COMMENT_NODE */ &&\n                node.nodeValue === textMarkerContent) {\n                const parent = node.parentNode;\n                // If we don't have a previous node add a marker node.\n                // If the previousSibling is removed, because it's another part\n                // placholder, or empty text, add a marker node.\n                if (node.previousSibling === null ||\n                    node.previousSibling !== previousNode) {\n                    parent.insertBefore(new Text(), node);\n                }\n                else {\n                    index--;\n                }\n                this.parts.push(new TemplatePart('node', index++));\n                nodesToRemove.push(node);\n                // If we don't have a next node add a marker node.\n                // We don't have to check if the next node is going to be removed,\n                // because that node will induce a marker if so.\n                if (node.nextSibling === null) {\n                    parent.insertBefore(new Text(), node);\n                }\n                else {\n                    index--;\n                }\n                currentNode = previousNode;\n                partIndex++;\n            }\n        }\n        // Remove text binding nodes after the walk to not disturb the TreeWalker\n        for (const n of nodesToRemove) {\n            n.parentNode.removeChild(n);\n        }\n    }\n    /**\n     * Returns a string of HTML used to create a <template> element.\n     */\n    _getHtml(strings, svg) {\n        const l = strings.length;\n        const a = [];\n        let isTextBinding = false;\n        for (let i = 0; i < l - 1; i++) {\n            const s = strings[i];\n            a.push(s);\n            // We're in a text position if the previous string matches the\n            // textRegex. If it doesn't and the previous string has no tags, then\n            // we use the previous text position state.\n            isTextBinding = s.match(textRegex) !== null ||\n                (s.match(hasTagsRegex) !== null && isTextBinding);\n            a.push(isTextBinding ? textMarker : attributeMarker);\n        }\n        a.push(strings[l - 1]);\n        const html = a.join('');\n        return svg ? `<svg>${html}</svg>` : html;\n    }\n}\nexport const getValue = (part, value) => {\n    // `null` as the value of a Text node will render the string 'null'\n    // so we convert it to undefined\n    if (value != null && value.__litDirective === true) {\n        value = value(part);\n    }\n    return value === null ? undefined : value;\n};\nexport const directive = (f) => {\n    f.__litDirective = true;\n    return f;\n};\nexport class AttributePart {\n    constructor(instance, element, name, strings) {\n        this.instance = instance;\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n        this.size = strings.length - 1;\n    }\n    setValue(values, startIndex) {\n        const strings = this.strings;\n        let text = '';\n        for (let i = 0; i < strings.length; i++) {\n            text += strings[i];\n            if (i < strings.length - 1) {\n                const v = getValue(this, values[startIndex + i]);\n                if (v &&\n                    (Array.isArray(v) || typeof v !== 'string' && v[Symbol.iterator])) {\n                    for (const t of v) {\n                        // TODO: we need to recursively call getValue into iterables...\n                        text += t;\n                    }\n                }\n                else {\n                    text += v;\n                }\n            }\n        }\n        this.element.setAttribute(this.name, text);\n    }\n}\nexport class NodePart {\n    constructor(instance, startNode, endNode) {\n        this.instance = instance;\n        this.startNode = startNode;\n        this.endNode = endNode;\n        this._previousValue = undefined;\n    }\n    setValue(value) {\n        value = getValue(this, value);\n        if (value === null ||\n            !(typeof value === 'object' || typeof value === 'function')) {\n            // Handle primitive values\n            // If the value didn't change, do nothing\n            if (value === this._previousValue) {\n                return;\n            }\n            this._setText(value);\n        }\n        else if (value instanceof TemplateResult) {\n            this._setTemplateResult(value);\n        }\n        else if (Array.isArray(value) || value[Symbol.iterator]) {\n            this._setIterable(value);\n        }\n        else if (value instanceof Node) {\n            this._setNode(value);\n        }\n        else if (value.then !== undefined) {\n            this._setPromise(value);\n        }\n        else {\n            // Fallback, will render the string representation\n            this._setText(value);\n        }\n    }\n    _insert(node) {\n        this.endNode.parentNode.insertBefore(node, this.endNode);\n    }\n    _setNode(value) {\n        this.clear();\n        this._insert(value);\n        this._previousValue = value;\n    }\n    _setText(value) {\n        const node = this.startNode.nextSibling;\n        if (node === this.endNode.previousSibling &&\n            node.nodeType === Node.TEXT_NODE) {\n            // If we only have a single text node between the markers, we can just\n            // set its value, rather than replacing it.\n            // TODO(justinfagnani): Can we just check if _previousValue is\n            // primitive?\n            node.textContent = value;\n        }\n        else {\n            this._setNode(document.createTextNode(value === undefined ? '' : value));\n        }\n        this._previousValue = value;\n    }\n    _setTemplateResult(value) {\n        let instance;\n        if (this._previousValue &&\n            this._previousValue.template === value.template) {\n            instance = this._previousValue;\n        }\n        else {\n            instance =\n                new TemplateInstance(value.template, this.instance._partCallback);\n            this._setNode(instance._clone());\n            this._previousValue = instance;\n        }\n        instance.update(value.values);\n    }\n    _setIterable(value) {\n        // For an Iterable, we create a new InstancePart per item, then set its\n        // value to the item. This is a little bit of overhead for every item in\n        // an Iterable, but it lets us recurse easily and efficiently update Arrays\n        // of TemplateResults that will be commonly returned from expressions like:\n        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n        // If _previousValue is an array, then the previous render was of an\n        // iterable and _previousValue will contain the NodeParts from the previous\n        // render. If _previousValue is not an array, clear this part and make a new\n        // array for NodeParts.\n        if (!Array.isArray(this._previousValue)) {\n            this.clear();\n            this._previousValue = [];\n        }\n        // Lets us keep track of how many items we stamped so we can clear leftover\n        // items from a previous render\n        const itemParts = this._previousValue;\n        let partIndex = 0;\n        for (const item of value) {\n            // Try to reuse an existing part\n            let itemPart = itemParts[partIndex];\n            // If no existing part, create a new one\n            if (itemPart === undefined) {\n                // If we're creating the first item part, it's startNode should be the\n                // container's startNode\n                let itemStart = this.startNode;\n                // If we're not creating the first part, create a new separator marker\n                // node, and fix up the previous part's endNode to point to it\n                if (partIndex > 0) {\n                    const previousPart = itemParts[partIndex - 1];\n                    itemStart = previousPart.endNode = document.createTextNode('');\n                    this._insert(itemStart);\n                }\n                itemPart = new NodePart(this.instance, itemStart, this.endNode);\n                itemParts.push(itemPart);\n            }\n            itemPart.setValue(item);\n            partIndex++;\n        }\n        if (partIndex === 0) {\n            this.clear();\n            this._previousValue = undefined;\n        }\n        else if (partIndex < itemParts.length) {\n            const lastPart = itemParts[partIndex - 1];\n            // Truncate the parts array so _previousValue reflects the current state\n            itemParts.length = partIndex;\n            this.clear(lastPart.endNode.previousSibling);\n            lastPart.endNode = this.endNode;\n        }\n    }\n    _setPromise(value) {\n        value.then((v) => {\n            if (this._previousValue === value) {\n                this.setValue(v);\n            }\n        });\n        this._previousValue = value;\n    }\n    clear(startNode = this.startNode) {\n        let node;\n        while ((node = startNode.nextSibling) !== this.endNode) {\n            node.parentNode.removeChild(node);\n        }\n    }\n}\nexport const defaultPartCallback = (instance, templatePart, node) => {\n    if (templatePart.type === 'attribute') {\n        return new AttributePart(instance, node, templatePart.name, templatePart.strings);\n    }\n    else if (templatePart.type === 'node') {\n        return new NodePart(instance, node, node.nextSibling);\n    }\n    throw new Error(`Unknown part type ${templatePart.type}`);\n};\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\nexport class TemplateInstance {\n    constructor(template, partCallback = defaultPartCallback) {\n        this._parts = [];\n        this.template = template;\n        this._partCallback = partCallback;\n    }\n    update(values) {\n        let valueIndex = 0;\n        for (const part of this._parts) {\n            if (part.size === undefined) {\n                part.setValue(values[valueIndex]);\n                valueIndex++;\n            }\n            else {\n                part.setValue(values, valueIndex);\n                valueIndex += part.size;\n            }\n        }\n    }\n    _clone() {\n        const fragment = document.importNode(this.template.element.content, true);\n        if (this.template.parts.length > 0) {\n            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be\n            // null\n            const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT */, null, false);\n            const parts = this.template.parts;\n            let index = 0;\n            let partIndex = 0;\n            let templatePart = parts[0];\n            let node = walker.nextNode();\n            while (node != null && partIndex < parts.length) {\n                if (index === templatePart.index) {\n                    this._parts.push(this._partCallback(this, templatePart, node));\n                    templatePart = parts[++partIndex];\n                }\n                else {\n                    index++;\n                    node = walker.nextNode();\n                }\n            }\n        }\n        if (this.template.svg) {\n            const svgElement = fragment.firstChild;\n            fragment.removeChild(svgElement);\n            const nodes = svgElement.childNodes;\n            for (let i = 0; i < nodes.length; i++) {\n                fragment.appendChild(nodes.item(i));\n            }\n        }\n        return fragment;\n    }\n}\n//# sourceMappingURL=lit-html.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lit-html/lit-html.js\n// module id = 0\n// module chunks = 0","import { App } from './app.js';\r\nrequire('./app.css');\r\n\r\nconst app = new App(document.body);\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 1\n// module chunks = 0","import { html, render } from 'lit-html/lib/lit-extended';\r\n// import { directive } from 'lit-html';\r\n// console.log(\"directive=\", directive);\r\n\r\n// const myComponent = (f) => directive((part) => {\r\n//   return f();\r\n// });\r\n\r\nconst title = 'title';\r\nconst header = html`<h1>${title}</h1>`;\r\n\r\nexport class App {\r\n  get counter() { return this._counter || 0;}\r\n  set counter(v) { this._counter = v; this.invalidate(); }\r\n  \r\n  constructor(parent) {\r\n    this.parent = parent;\r\n    this.counter = 0;\r\n  }\r\n  \r\n  _inc(e) {\r\n    console.log('App:inc', e);\r\n    this.counter++;\r\n  }\r\n\r\n  _dec(e) {\r\n    console.log('App:dec', e);\r\n    this.counter--;\r\n  }\r\n  \r\n  render() {\r\n    return html`\r\n      ${header}\r\n      <button on-click=\"${e => this._dec(e)}\">-</button>\r\n      ${this.counter}\r\n      <button on-click=\"${e => this._inc(e)}\">+</button>\r\n    `;\r\n  }\r\n  \r\n  invalidate() {\r\n    // Not sure for reason. One line works fine.\r\n    // render(this.render(), this.parent);\r\n    if (!this.needsRender) {\r\n      this.needsRender = true;\r\n      Promise.resolve().then(() => {\r\n        this.needsRender = false;\r\n        render(this.render(), this.parent);\r\n      });\r\n    }\r\n  }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app.js\n// module id = 2\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { AttributePart, defaultPartCallback, getValue, render as baseRender } from '../lit-html.js';\nexport { html } from '../lit-html.js';\n/**\n *\n * @param result Renders a `TemplateResult` to a container using the\n * `extendedPartCallback` PartCallback, which allows templates to set\n * properties and declarative event handlers.\n *\n * Properties are set by default, instead of attributes. Attribute names in\n * lit-html templates preserve case, so properties are case sensitive. If an\n * expression takes up an entire attribute value, then the property is set to\n * that value. If an expression is interpolated with a string or other\n * expressions then the property is set to the string result of the\n * interpolation.\n *\n * To set an attribute instead of a property, append a `$` suffix to the\n * attribute name.\n *\n * Example:\n *\n *     html`<button class$=\"primary\">Buy Now</button>`\n *\n * To set an event handler, prefix the attribute name with `on-`:\n *\n * Example:\n *\n *     html`<button on-click=${(e)=> this.onClickHandler(e)}>Buy Now</button>`\n *\n */\nexport function render(result, container) {\n    baseRender(result, container, extendedPartCallback);\n}\nexport const extendedPartCallback = (instance, templatePart, node) => {\n    if (templatePart.type === 'attribute') {\n        if (templatePart.rawName.startsWith('on-')) {\n            const eventName = templatePart.rawName.substring(3);\n            return new EventPart(instance, node, eventName);\n        }\n        if (templatePart.name.endsWith('$')) {\n            const name = templatePart.name.substring(0, templatePart.name.length - 1);\n            return new AttributePart(instance, node, name, templatePart.strings);\n        }\n        return new PropertyPart(instance, node, templatePart.rawName, templatePart.strings);\n    }\n    return defaultPartCallback(instance, templatePart, node);\n};\nexport class PropertyPart extends AttributePart {\n    setValue(values, startIndex) {\n        const s = this.strings;\n        let value;\n        if (s.length === 2 && s[0] === '' && s[s.length - 1] === '') {\n            // An expression that occupies the whole attribute value will leave\n            // leading and trailing empty strings.\n            value = getValue(this, values[startIndex]);\n        }\n        else {\n            // Interpolation, so interpolate\n            value = '';\n            for (let i = 0; i < s.length; i++) {\n                value += s[i];\n                if (i < s.length - 1) {\n                    value += getValue(this, values[startIndex + i]);\n                }\n            }\n        }\n        this.element[this.name] = value;\n    }\n}\nexport class EventPart {\n    constructor(instance, element, eventName) {\n        this.instance = instance;\n        this.element = element;\n        this.eventName = eventName;\n    }\n    setValue(value) {\n        const listener = getValue(this, value);\n        if (listener === this._listener) {\n            return;\n        }\n        if (listener == null) {\n            this.element.removeEventListener(this.eventName, this);\n        }\n        else if (this._listener == null) {\n            this.element.addEventListener(this.eventName, this);\n        }\n        this._listener = listener;\n    }\n    handleEvent(event) {\n        if (typeof this._listener === 'function') {\n            this._listener.call(this.element, event);\n        }\n        else if (typeof this._listener.handleEvent === 'function') {\n            this._listener.handleEvent(event);\n        }\n    }\n}\n//# sourceMappingURL=lit-extended.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lit-html/lib/lit-extended.js\n// module id = 3\n// module chunks = 0"],"sourceRoot":""}